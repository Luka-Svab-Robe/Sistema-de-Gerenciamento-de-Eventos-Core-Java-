Sistema de Gerenciamento de Eventos (Core-Java)
Descrição
Este projeto consiste em uma aplicação de console (CLI) desenvolvida em Java para o gerenciamento de eventos. A solução implementa funcionalidades de CRUD para eventos e usuários, além de lógicas para consulta e participação. O design do sistema prioriza a separação de responsabilidades (SoC) e a manutenibilidade do código, utilizando uma arquitetura em camadas e o paradigma de Orientação a Objetos.

Arquitetura e Padrões de Projeto
A arquitetura do sistema é inspirada no padrão MVC (Model-View-Controller), adaptado para uma aplicação de console, e segue os princípios de uma Arquitetura em Camadas (Layered Architecture).

Model: Representa as entidades de domínio (User, Event) e enums (Category). São objetos POJO (Plain Old Java Object) que carregam os dados e o estado da aplicação.

View: A camada de apresentação (ConsoleView) é responsável exclusivamente pela interação com o usuário via I/O do console. Ela não contém nenhuma regra de negócio, atuando apenas como renderizador de dados e capturador de entradas.

Controller: O MainController atua como o orquestrador do fluxo da aplicação. Ele recebe as requisições da View, delega as operações de negócio para a camada de Serviço e retorna a resposta para a View.

Service Layer: A camada de serviço (EventService, UserService) encapsula a lógica de negócio da aplicação. Ela é agnóstica em relação à interface com o usuário e à forma de persistência dos dados.

Repository Pattern: A camada de persistência (EventRepository) abstrai o acesso aos dados. Este padrão desacopla a lógica de negócio dos detalhes de implementação do armazenamento, permitindo que a fonte de dados (atualmente, um arquivo serializado) possa ser trocada por um banco de dados sem impactar as camadas superiores.

Estrutura do Projeto
O código-fonte está modularizado em pacotes que representam as camadas da arquitetura:

main: Ponto de entrada da aplicação (App.java).

controller: Orquestra o fluxo de dados entre a View e os Services.

model: Contém as classes de domínio (entidades).

view: Responsável pela interface de linha de comando.

service: Implementa as regras de negócio do sistema.

repository: Abstrai o acesso e a manipulação da fonte de dados.

Persistência de Dados
Para a persistência dos dados dos eventos, foi utilizada a Serialização de Objetos Java.

Implementação: A lista de objetos Event é serializada e salva em um arquivo binário (events.data).

Justificativa: Esta abordagem foi escolhida pela sua simplicidade e por não exigir dependências externas (como um SGBD), sendo adequada para o escopo de uma aplicação de console local.

Limitações: A serialização nativa pode apresentar desafios de versionamento e não é performática para grandes volumes de dados ou acesso concorrente.

Tecnologias e APIs
Linguagem: Java (JDK 8+)

APIs Core:

java.time (JSR-310): Para manipulação precisa de datas e horas (LocalDateTime).

java.io: Para serialização de objetos e manipulação de arquivos (ObjectInputStream, ObjectOutputStream).

java.util.stream: Utilizada para processamento declarativo e funcional de coleções de dados.

java.util.UUID: Para geração de identificadores únicos para as entidades.

Como Compilar e Executar
Via IDE
Importe o projeto em uma IDE compatível com Java (Eclipse, IntelliJ IDEA, etc.).

Localize a classe main.App.java.

Execute o método main() para iniciar a aplicação. A IDE se encarregará da compilação.

Via Linha de Comando
Navegue até a pasta src do projeto.

Compile todos os arquivos .java:

javac -d ../bin */*.java

Navegue até a pasta bin que foi criada:

cd ../bin

Execute a aplicação:

java main.App

Possíveis Melhorias e Evolução
Refatoração da Persistência: Substituir a serialização em arquivo por um banco de dados embarcado (como H2 ou SQLite) ou um SGBD completo (PostgreSQL, MySQL) utilizando JDBC ou um framework ORM (JPA/Hibernate).

Testes Unitários e de Integração: Implementar uma suíte de testes com JUnit e Mockito para garantir a qualidade e a estabilidade do código, especialmente na camada de serviço.

Gerenciamento de Dependências: Adotar Maven ou Gradle para gerenciar as dependências do projeto e automatizar o processo de build.

Exposição via API REST: Refatorar a aplicação para expor suas funcionalidades através de uma API RESTful (utilizando Spring Boot ou JAX-RS), desacoplando o back-end do front-end.

Interface Gráfica: Desenvolver uma interface gráfica (GUI) com JavaFX ou Swing, ou uma interface web (Web UI) com um framework como React ou Angular, consumindo a API REST.